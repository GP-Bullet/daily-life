控制硬件——系统调用往往作为硬件资源和用户空间的抽象接口，比如读写文件时用到的write/read调用。

l 设置系统状态或读取内核数据——因为系统调用是用户空间和内核的唯一通讯手段[2]，所以用户设置系统状态，比如开/关某项内核服务（设置某个内核变量），或读取内核数据都必须通过系统调用。比如getpgid、getpriority、setpriority、sethostname

l 进程管理——一系统调用接口是用来保证系统中进程能以多任务在虚拟内存环境下得以运行。比如 fork、clone、execve、exit等

第二，什么服务应该存在于内核；或者说什么功能应该实现在内核而不是在用户空间。这个问题并没有明确的答案，有些服务你可以选择在内核完成，也可以在用户空间完成。选择在内核完成通常基于以下考虑：

l 服务必须获得内核数据，比如一些服务必须获得中断或系统时间等内核数据。

l 从安全角度考虑，在内核中提供的服务相比用户空间提供的毫无疑问更安全，很难被非法访问到。

l 从效率考虑，在内核实现服务避免了和用户空间来回传递数据以及保护现场等步骤，因此效率往往要比在用户空间实现高许多。比如,httpd等服务。

l 如果内核和用户空间都需要使用该服务，那么最好实现在内核空间，比如随机数产生。




结合用户空间的执行路径，该程序大致可归结为以下几个步骤：

1 该程序调用libc库的封装函数getpid。该封装函数将系统调用号_NR_getpid（第20个）压入EAX寄存器，

2 调用软中断 int 0x80 进入内核。

（以下进入内核态）

3 在内核中首先执行system_call，接着执行根据系统调用号在调用表中查找到的对应的系统调用服务例程sys_getpid。

4．执行sys_getpid服务例程。

5．执行完毕后，转入ret_from_sys_call例程，系统调用中返回。


int $0x80指令的目的是产生一个编号为128的编程异常，这个编程异常对应的是中断描述符表IDT中的第128项——也就是对应的系统门描述符。门描述符中含有一个预设的内核空间地址，它指向了系统调用处理程序：system_call()