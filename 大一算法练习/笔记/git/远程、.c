/*
//*git clone 
命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝

远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。
Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, 
（更新了远程分支之后）再用远程分享你的工作成果。

你可能想问这些远程分支的前面的 o/ 是什么意思呢？好吧, 远程分支有一个命名规范 —— 它们的格式是:

<remote name>/<branch name>
因此，如果你看到一个名为 o/main 的分支，那么这个分支就叫 main，远程仓库的名称就是 o。

大多数的开发人员会将它们主要的远程仓库命名为 origin，并不是 o。这是因为当你用 git clone 某个仓库时，Git 已经帮你把远程仓库的名称设置为 origin 了

不过 origin 对于我们的 UI 来说太长了，因此不得不使用简写 o :) 但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 origin!




Git 变成了分离 HEAD 状态，当添加新的提交时 o/main 也不会更新。
这是因为 o/main 只有在远程仓库中相应的分支更新了以后才会更新。

//*get fetch(获取数据)

C2,C3 被下载到了本地仓库，
同时远程分支 o/main 也被更新，反映到了这一变化


从远程仓库下载本地仓库中缺失的提交记录
更新远程分支指针(如 o/main)
git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态

你可以将 git fetch 的理解为单纯的下载操作。


//*git pull

先抓取更新再合并到本地分支这个流程很常用，
因此 Git 提供了一个专门的命令来完成这两个操作。
它就是我们要讲的 git pull。

我们用 fetch 下载了 C3, 然后通过 git merge o/main 合并了这一提交记录。
现在我们的 main 分支包含了远程仓库中的更新（在本例中远程仓库名为 origin）

这清楚地说明了 git pull 就是 git fetch 和 git merge 的缩写！


//*git push
git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。
一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！

在教程中我们使用的是 upstream。
这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。
远程仓库接收了 C2，远程仓库中的 main 分支也被更新到指向 C2 了，
我们的远程分支 (o/main) 也同样被更新了。所有的分支都同步了！



*历史偏移
因为命令失败了！git push 失败是因为你最新提交的 C3 基于远程分支中的 C1。
而远程仓库中该分支已经更新到 C2 了，所以 Git 拒绝了你的推送请求。

那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。

git pull 就是 fetch 和 merge 的简写，
类似的 
*git pull --rebase 就是 fetch 和 rebase 的简写！



*远程服务器拒绝!(Remote Rejected)
! [远程服务器拒绝] main -> main
(TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)

你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,
但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.

解决办法
新建一个分支feature, 推送到远程服务器. 
然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.



git 

!merge and rebase
一些开发人员喜欢保留提交历史，因此更偏爱 merge。
而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 :D




远程分支 main 和本地的 main 分支进行了关联。
这种关联在以下两种情况下可以清楚地得到展示：

pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。
隐含的合并目标由这个关联确定的。


push 操作时, 我们把工作从 main 推到远程仓库中的 main 分支(同时会更新远程分支 o/main) 。
这个推送的目的地也是由这种关联确定的！




*/