### sched/cfs.rs源码


#### CFSQueue

```rust
struct CFSQueue {
    /// 当前cpu上执行的进程剩余的时间片
    cpu_exec_proc_jiffies: i64,
    /// 队列的锁
    lock: RawSpinlock,
    /// 进程的队列
    queue: RBTree<i64, &'static mut process_control_block>,
    /// 当前核心的队列专属的IDLE进程的pcb
    idle_pcb: *mut process_control_block,
}
```

注意：这里队列中的锁是一个自旋锁，（代码性能待分析）

相对于互斥锁，自旋锁不需要系统调用和上下文切换的开销，因为它不会将线程挂起，而是在用户空间内忙等。这样，在多核 CPU 上，如果锁占用时间很短，自旋锁的性能可能比互斥锁更好。但是，当锁的持有时间较长或者多个线程竞争时，自旋锁会带来严重的 CPU 占用问题

>Linux 的多线程应用程序使用的锁（例如 pthread_mutex_t）不是自旋锁，当上锁失败时会切换到其它进程执行
>
>互斥锁和自旋锁的优劣：互斥锁和自旋锁的本质区别在于加锁失败时，是否会释放 CPU。
>
>互斥锁在加锁失败时，会释放 CPU
>• 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
>• 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。
>Linux不使用自旋锁的原因：
>
>• 可移植性：pthread_mutex_t 是 POSIX 标准中定义的一种互斥锁，不仅可以在 Linux 系统上使用，还可以在其他的 POSIX 兼容系统上使用，提高了应用程序的可移植性。
>• 性能：自旋锁在多核处理器上可以提高并发性能，但是在单核处理器上可能会降低性能，因为自旋锁需要不断地检查锁的状态，如果锁一直处于被占用的状态，就会一直占用处理器时间。而pthread_mutex_t 是一种阻塞锁，在锁被占用时，会将线程挂起，让出处理器时间，从而避免了空转浪费处理器资源的情况。
>• 死锁：使用自旋锁需要非常小心，否则容易出现死锁的情况。例如，当一个线程持有一个自旋锁并等待另一个自旋锁时，如果另一个线程持有了这个自旋锁并等待第一个自旋锁，就会出现死锁。而 pthread_mutex_t 是一种阻塞锁，在锁的等待队列中维护了线程的等待关系，可以避免死锁的情况。

##### CFSQueue 内部基于红黑树

- `enqueue(&mut self, pcb: &'static mut process_control_block)`: 

  *添加进程到队列中*

  将进程添加到红黑树中，并按照进程虚拟运行时间进行排序。如果进程是 IDLE 进程，则不加入队列（因为 IDLE 进程是空闲状态，不需要参与调度）。

- `dequeue(&mut self) -> &'static mut process_control_block`: 

  *从队列中弹出一个进程来执行*

  若在队列中有可用进程，则返回下一个要执行的进程，否则返回 IDLE 进程的 PCB。在获取进程之前，需要使用自旋锁来确保操作的原子性。

- `min_vruntime(&self) -> Option<i64>`: 

  *如果队列不为空，则返回队列中进程的最小虚拟运行时间，否则返回 None。*

- `get_cfs_queue_size(&mut self) -> usize`: 

  *返回队列中当前进程的个数。*

  

#### **SchedulerCFS**

- `new()` 

  创建一个新的 `SchedulerCFS` 实例，并初始化 cpu queue 变量。通过循环来为每个 CPU 核心分别创建一个 `CFSQueue` 队列，使用Vec作为存储结构。

- `sched()` 

  在当前 CPU 上进行 CFS 调度。

  如果当前不是*running态*，或者*当前进程的虚拟运行时间大于等于下一个进程*的，那就需要切换：

  1. 如果本次切换是由于时间片到期引发的，则需要将当前进程重新加入到CFSQueue中；

     另外一种情况是当前虚拟运行时间大于下一个进程

  2. 设置下一个进程可以执行的时间，这需要根据下一个进程的优先级和CPU的负载情况动态计算出可用时间片，然后进行更新。

  3. 返回下一个要执行的进程的PCB。

  如果不需要进行进程切换，那么就需要执行以下操作：

  1. 设置下一个进程可以执行的时间，这也需要根据进程优先级和CPU负载情况动态计算出可用时间片，然后进行更新。
  2. 将下一个进程重新加入到就绪队列中，等待下次调度。
  3. 返回None，表示本次调度没有进行进程切换。

- `enqueue()`

  *向进程的 CPU 对应的 CFS 队列中添加一个进程。*

- `update_cpu_exec_proc_jiffies()` 

  *只是简单地将指定队列中已经执行的进程可用的CPU时间片数设置为10，当一个进程的时间片用完之后，该进程就会被放回到队列中等待重新进行调度。*

  改进：根据所有进程的优先级和当前所处队列中的进程数量，动态计算每个进程应该被分配的时间片数量。
- `timer_update_jiffies()` 

  *时钟中断触发要调用，用于更新当前进程在其 CPU 上的可执行时间。*
  
  `virtual_runtime`是指当前进程已经占用的CPU时间片数量。它在进程切换时记录，并在每次调度时递增。由于CFS调度算法通过将CPU时间均分给各个进程，以达到公平分配CPU资源的目的，因此采用虚拟运行时间作为优先级度量标准可以更好地实现公平性。
  
  这个函数非常关键，它涉及了`virtual_runtime`的增加和`cpu_exe_proc_jiffies`的减少。
  
  通过它们的变化才能判断是否需要调度，每次时钟中断到达为一个时间片，则当前进程虚拟运行时间加一，若其虚拟运行时间有高于其他进程的，则会进程切换，从而实现了公平调度。时间片耗尽标志位设置为需要进行调度的状态。
  
- `enqueue_reset_vruntime()` 

  *将进程添加到 CPU 的 CFS 调度队列中。如果队列不为空，则将虚拟运行时间重置为当前队列中最小的虚拟运行时间。*

  

一些问题：

1.饥饿问题是否存在，如何解决?

2.什么情况下会触发sched()?

3.为什么每次调用sched()都要把下一个进程的时间片设置为10？



