## 开源之夏项目申请书





---


- [1. 项目基本要求](#c1)
  - [1.1 项目基本要求](#c1.1)
  - [1.2 项目相关仓库](#c1.2)

- [2. 初步构想](#c2)
- [3. 项目详细方案](#c3)
  - [3.1 Cgroup](#c3.1)
  - [3.2 进程组引入](#c3.2)
  - [3.3 进程调度](#c3.3)
  - [3.4 组调度的实现](#c3.4)
  - [3.5 系统调用接口](#c3.5)
- [4. 项目开发时间规划](#c4)
  - [期望](#c4.1)







项目名称：【内核】进程组调度机制设计与实现

项目导师：汤峰

日期：2023.5.17

申请人：高鹏

申请人邮箱：g1285719445@gmail.com

---



### <a name="c1">1.  项⽬背景</a>

#### <a name="c1.1">1.1 项目基本要求</a>

​       为提高DragonOS的资源利用率、调度决策合理性，需要将进程组的概念以及组调度算法引入DragonOS，将不同进程组之间的资源竞争隔离开来，每个进程组拥有独立的调度器和资源分配器。通过使用组调度，可以在系统中为不同类型的应用程序分配不同的系统资源，使得不同类型的应用程序在系统中更加公平地竞争资源，从而提高系统的整体性能。


#### <a name="c1.2">1.2 项目相关仓库</a>

- DragonOS主仓库:https://github.com/DragonOS-Community/DragonOS
  master是待增加功能的目标分支



### <a name="c2">2. 初步构想</a>

本项目将使用Rust语言编写，编写时要利用Rust语言的特点，提高系统的安全性。

基于Linux实现的原理，对现有的进程调度机制之上实现组调度，更好地提高系统的整体性能。

编写时要利用DragonOS本身的独特性，阅读DragonOS源码，使得系统最后各部分协调运作。

及时测试调度功能的使用，严格代码审查，减少漏洞的产生。



### <a name="c3">3. 项目详细方案</a>

#### <a name="c3.1">3.1 Cgroup</a>

在引入进程组之前，必须要深入了解Cgroup，Cgroup用于控制（限制）进程对系统各种资源的使用，我们要完成的是对CPU资源的限制。（分析Linux2.6.25的实现)

- 1. 数据结构

Cgroup使用虚拟文件系统来管理，层级中各个 cgroup组成树状关系

<img src="/home/biu/Downloads/cgroup_tree.png" alt="cgroup_tree" style="zoom: 67%;" />

从实现来看，`cgroup` 只是把 多个进程 组织成 控制进程组 ，而真正限制资源使用的是各个 `子系统`。

Cgroup的数据结构涉及较多，这里建立关系图来解释：



![3 (1)](/home/biu/Downloads/3 (1).png)



下面是更为详细的数据结构，这里引用的是https://blog.csdn.net/hu1610552336/article/details/118642410
![img](https://img-blog.csdnimg.cn/20210710232906107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1MTYxMDU1MjMzNg==,size_16,color_FFFFFF,t_70)



- 2. Cgroup挂载主要函数

<img src="/home/biu/Downloads/6 .png" alt="4" style="float: left; margin-right: 10px; zoom: 80%;" />`cgroup_get_sb()` 函数会调用 `kzalloc()` 函数创建一个 `cgroupfs_root` 结构。`cgroupfs_root` 结构主要用于描述这个挂载点的信息。如`subsys_list` 表示附加到此 `层级` 的所有 `子系统`，而 `top_cgroup` 表示此 `层级` 的根 `cgroup`。

`rebind_subsystems()` 函数把挂载时指定要附加的 `子系统` 添加到 `cgroupfs_root` 结构的 `subsys_list` 链表中，并且为根 `cgroup` 的 `subsys` 字段设置各个 `子系统` 的资源控制统计信息对象。

最后调用 `cgroup_populate_dir()` 函数向挂载目录创建 `cgroup` 的管理文件和各个 `子系统` 的管理文件。







<img src="/home/biu/Downloads/5.png" alt="5" style="float: left; margin-right: 10px; zoom: 80%;" />3.  向 Cgroup添加要进行资源控制的进程
通过向 `CGroup` 的 `tasks` 文件写入要进行资源控制的进程PID，即可以对进程进行资源控制。向 `tasks` 文件写入进程PID是通过 `attach_task_by_pid()` 函数实现。

用 `cgroup_attach_task()` 函数把进程添加到 `cgroup` 中。

首先会调用 `find_css_set()` 函数查找或者创建一个 `css_set` 对象。用于收集不同 `cgroup` 上附加的 `子系统` 资源统计信息对象。

`cgroup_attach_task()` 函数会调用附加在 `层级` 上的所有 `子系统` 的 `attach()` 








- 4.  Cgroup对各系统资源的限制

   - 主要是实现CPU控制

     Cgroup对进程组使用cpu的限制是通过cpu和cpuset两个子系统来完成。cpu子系统主要限制进程的时间片大小，在调度系统中对进程组的权重进行设置。

     cpuset子系统中的`cpuset.cpus`和`cpuset.mems`可对进程组设定可访问的CPU和内存节点。

     为子进程选择就绪队列`select_task_rq()`其内部实现需要涉及CPU的检查操作；在调度一个进程时，也要通过`select_task_rq()`进行同样的对比选择。保证只在cpus_allowed所限定的cpu中运行。

     通过`alloc_pages()`来实现物理内存的分配工作，在选择`node`的过程中会进行`mems_allowd`判断过程。

     

   - 内存控制

     可以向 cgroup的 `memory.limit_in_bytes` 文件写入要限制使用的内存大小，同时为当前cgroup生成一份内存使用情况报告。

     申请内存时，通过`mem_cgroup_charge_common()` 函数会对进程内存使用情况进行检测，如果进程已经超过了 `cgroup` 设置的限制，那么就会尝试进行释放一些不用的内存

   - 块I/O控制

     Cgroup中通过blkio子系统完成对块设备I/O的控制，调度算法为CFQ（完全公平队列），主要通过`blkio.weight`文件在用户态设定当前进程组访问块I/O的权重。
     




#### <a name="c3.2" >3.2 进程组引入</a>

在 Linux 内核中，使用 `task_group` 结构表示一个进程组。其定义如下：

```c
struct task_group {
    struct cgroup_subsys_state css; // cgroup相关结构

    struct sched_entity **se;       // 调度实体(每个CPU分配一个)
    struct cfs_rq **cfs_rq;         // 完全公平调度运行队列(每个CPU分配一个)
    unsigned long shares;           // 当前进程组权重(用于获取时间片)
    ...

    // 由于进程组支持嵌套, 也就是说进程组可以包含进程组
    // 所以, 进程组可以通过下面3个成员组成一个树结构
    struct task_group *parent;  // 父进程组
    struct list_head siblings;  // 兄弟进程组
    struct list_head children;  // 子进程组
};
```



#### <a name="c3.3" >3.3 进程调度</a>

通过阅读DragonOS/sched源码，分析DragonOS目前已经能够实现的进程调度。

详细文档已上传在DragonOS论坛

https://bbs.dragonos.org/forum.php?mod=viewthread&tid=82&extra=page%3D1

<img src="/home/biu/Downloads/抽象类.png" alt="抽象类" style="zoom: 67%;" />

**1. CFS_vatual_runtime**

CFS 80% 的设计都可以总结为一句话：**将真实 CPU 建模为一个“理想、精确的多任务 CPU”** “理想多任务 CPU” 掌控 100% 物理资源，能精确地以相同速度并行执行多个进程， 每个任务的速度都是 `1/nr_running`。

关键概念`vruntime`，采用虚拟运行时间作为优先级度量标准可以更好地实现公平性。

- vruntime 表示进程真正在 CPU 上执行的时间，不包括任何形式的等待时间；
- 注意机器一般都是多核的，因此 vruntime 是在多个 CPU 上执行时间的累加。

函数timer_update_jiffies()

 *每次时钟中断触发要调用，用于更新当前进程在其 CPU 上的可执行时间。*

这个函数非常关键，它涉及了`virtual_runtime`的增加和`cpu_exe_proc_jiffies`的减少。

通过它们的变化才能判断是否需要调度，每次时钟中断到达为一个时间片，则当前进程虚拟运行时间加一，若其虚拟运行时间有高于其他进程的，则会进程切换，从而实现了公平调度。时间片耗尽标志位设置为需要进行调度的状态。

**2. SchedulerRT_sched()**

- 取出当前进程的 PCB，将其 PF_NEED_SCHED 标记置为 0；

- 调用 `pick_next_task_rt` 函数挑选下一个进程，如果没有可运行的实时进程，则抛出错误；

- `SCHED_FIFO` 策略，判断被挑选的进程是否比当前进程`优先级`高

  如果不是，则将被挑选的进程重新加入到就绪队列中等待下次执行，

  如果是，则将当前进程重新加入到就绪队列中，并返回被挑选的进程的 PCB；

- `SCHED_RR` 策略，判断被挑选的进程与当前进程的优先级

  如果被挑选进程的优先级比当前进程高或者相等，则判断其`时间片`是否已耗尽，如果时间片未耗尽，则将当前进程重新加入到就绪队列中，并返回被挑选的进程的 PCB；

  如果被挑选进程的优先级比当前进程低，则将被挑选进程重新加入到就绪队列的队首等待下次执行。

- 如果没有可执行的进程，则返回 None。

#### <a name="c3.4" >3.4 组调度的实现</a>

很多情况下，进程会组织成进程组（task group）的形式， 用户希望先对进程组分配 CPU 份额，再在每个进程组里面实现公平调度。	

假设CPU的数量为2,`task_group`、`sched_entity` 和 `cfs_rq` 这三个结构的关系：

![7](/home/biu/Downloads/7.png)

在DragonOS已经实现的调度算法基础之上实现组调度，需要区分调度实体是进程还是进程组，参考Linux的实现，在sched_entity结构使用`my_q`字段，当设置为NULL时，说明这个实体是一个进程。如果这个字段指向一个可运行队列时，说明这个实体是一个进程组。

此时修改后的`pick_next_task()`流程为：

1. 从根进程组中筛选出最优的可运行实体（进程或进程组）。
2. 如果筛选出来的实体是进程，那么直接返回这个进程。
3. 如果筛选出来的实体是进程组，那么将会继续对这个进程组中的可运行队列进行筛选，直至筛选出一个可运行的进程。

#### <a name="c3.5" >3.5 系统调用接口</a>
- 创建进程组的系统调用：
setpgid()
实现代码：kernel/setpgid.c

当一个进程需要将子进程加入到进程组中时，可以使用setpgid()系统调用。调用该系统调用时，需要传递两个参数：第一个参数为待添加进程的进程ID，第二个参数为进程组ID，如果该进程组ID为0，则代表将该进程添加到与其PID相同的进程组中。setpgid()系统调用的原理是将指定的进程设置为指定进程组的组长进程，并将该进程添加到该进程组中。

- 管理进程组的系统调用：

getpgid(), getpgrp(), setpgrp()
实现代码：kernel/pgid.c

Linux中提供了三个系统调用来管理进程组，分别是getpgid()、getpgrp()和setpgrp()。其中，getpgid()和getpgrp()系统调用用于获取指定进程或当前进程所属的进程组ID，setpgrp()用于将当前进程设置为指定进程组的组长进程。

- 查询进程组资源使用情况的系统调用：

getrusage()
实现代码：kernel/sys.c

Linux中提供了getrusage()系统调用来查询指定进程或当前进程的资源使用情况，例如用户CPU时间、系统CPU时间、最大驻留集大小等等。该系统调用的原理是通过查询进程控制块（PCB）中的资源使用情况信息来计算进程的资源使用情况。

​	



### <a name="c4" >4. 项目开发时间规划</a>

因为实验室暑假留校，因此暑期我的学习时间很充足，可以保证项目的进行。

| 6.16 - 6.30 | 熟悉项目整体流程&nbsp;&nbsp;&nbsp; |
| :-: | :-: |
| **7.10 - 8.10** | **项目主要功能开发** |
| **8.10 - 8.31** | **代码调整、功能测试以及文档补全** |
| **9.1 - 9.31** | **继续帮助社区完善代码及文档** |

#### <a name="c4.1" >期望</a>

希望借助这个机会，切身地以完成⼀项具体任务的⽅式参与到开源社区 DragonOS 中，学习技术 知识，积累相关经验，为⽇后参与更多开源项⽬提供经验积累。也希望在开源之夏活动结束后能长期为 DragonOS 做贡献，见证社区的一点点壮大。



---

参考：

https://mp.weixin.qq.com/s/O28Db57jIbyjJ16UpjwpiQ

http://arthurchiao.art/blog/linux-cfs-design-and-implementation-zh/#121-%E5%89%8D%E6%8F%90config_cgroups

https://mp.weixin.qq.com/mp/homepage?__biz=MzI3NzA5MzUxNA==&hid=3

https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index