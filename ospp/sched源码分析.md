DragonOS sched源码分析



core.rs:

这段 Rust 代码实现了一个进程调度器，其中包含调度器的结构体和一些方法。其中包括：

- cpu_executing(cpu_id: u32) 方法：获取指定的 CPU 上正在执行的进程的 process_control_block（进程控制块）。

- get_cpu_loads(cpu_id: u32) 方法：获取指定 CPU 当前的负载情况。

- loads_balance(pcb: &mut process_control_block) 方法：将当前进程进行负载均衡，判断是否需要将其迁移到负载最小的 CPU 上。

- sched_enqueue(pcb: &'static mut process_control_block, reset_time: bool) 方法：将进程加入调度队列，并调用 loads_balance 方法进行负载均衡。

- sched_init() 方法：初始化进程调度器模块。

- sched_update_jiffies() 方法：当时钟中断到达时，更新时间片。

- sys_sched(regs: &'static mut pt_regs) -> u64 方法：让系统立即运行调度器的系统调用，根据调度结果统一进行切换。

- sched_set_cpu_idle(cpu_id: usize, pcb: *mut process_control_block) 方法：设置 CPU 空闲时运行的进程。

- sched_migrate_process(pcb: &'static mut process_control_block, target: usize) -> i32 方法：将进程迁移到另一个 CPU 核心。

  

rt.rs:

  ## 概述

  `sched_rt`模块提供了一个实时调度器的实现, 用于在操作系统中进行进程调度。该代码提供了一种将进程排队和出队的方法，通过优先级队列管理调度。

  ## 依赖项

  该模块依赖于多个 Rust 库，包括 core、alloc 和 crate 等。还需要使用 `bindings` 和 `spinlock` 库。

  ## 主要组件

  ### RTQueue

  这个结构体定义了一个队列来存储实时进程。它有一个锁，用于在同时被多个线程访问时管理队列。该队列使用链表来存储指向进程控制块的指针。

  ### SchedulerRT

  这个结构体负责管理多个 CPU 及其相应的队列。它还使用 load_list 来跟踪任何给定时刻在每个 CPU 上运行的进程数。它包括功能初始化实时调度器、从适当的队列中排队和出队进程以及选择下一个实时任务以执行的函数。

  ### `__get_rt_scheduler()`

  这是一个简单的函数，返回全局调度程序实例的可变引用。该函数用于从代码库中的其他部分访问和操作该实例。

  ## 功能

  通过`sched_rt_init()`函数初始化实时调度程序。它涉及创建“SchedulerRT”结构的新实例，并将引用存储在`RT_SCHEDULER_PTR`中。

  一旦初始化完成，可以使用`RTQueue`结构体的“enqueue()”和“enqueue_front()”函数将进程排队到实时队列中。出队操作使用“dequeue()”函数执行。注意，在排队进程时，如果它是空闲的，则不会将其添加到队列中。

  要选择要执行的下一个实时任务，请使用“pick_next_task_rt()”函数在所有 CPU 的每个优先级水平中进行搜索，直到找到可用进程为止。

  然后可以使用“__get_rt_scheduler()”函数访问全局调度程序实例并操作它，例如通过排队或出队进程。

  

   `SchedulerRT` 结构体实现 `Scheduler` trait 中的两个方法： `sched()` 和 `enqueue()`，具体如下：

  ### sched()

  该方法实现了实时调度器的基本逻辑。它首先从当前处理器中检索并删除标记为“需调度”的进程，并根据其策略（FIFO 或 RR）选择下一个要运行的进程。对于 FIFO 策略，如果挑选的进程优先级小于当前进程，则将其添加到队列中等待后续调度；否则，将当前进程放回队列，并返回所选进程。对于 RR 策略，如果所选进程的优先级大于或等于当前进程，则考虑该进程的时间片是否已经用尽。如果已用尽，则将其时间片重置，并将其添加到队列中，等待下一轮调度; 否则，将当前进程放回队列，并返回所选进程。如果当前进程的优先级更高，则不进行切换，将所选进程添加到队列顶部。

  ### enqueue()

  该方法接受传入的进程控制块作为参数，并将其添加到相应 CPU 上的队列中。在将进程添加到队列之前，它会记录当前时间，并将其添加到负载列表中。如果负载列表中的元素数量超过预设值，它将删除最早的元素。

  这两个方法帮助实现了实时调度器模块的最重要部分，即判断下一个运行的进程。`enqueue()` 方法对于添加新进程也很有用。

  ## 结论

  实时调度程序是操作系统进程调度的重要部分。如上所述，它涉及使用队列和优先级水平管理来确保实时任务的高效执行和无需过度延迟。



cfs.rs:

这段代码是一个CFS（Completely Fair Scheduler）调度器的实现，用于在操作系统中管理进程的调度。具体来说，它定义了一个结构体`SchedulerCFS`，其中包含每个CPU核心对应的调度队列`CFSQueue`。

`CFSQueue`中保存了进程控制块PCB（`process_control_block`）的指针，以及每个进程虚拟运行时间，进程的剩余时间片信息等。该队列使用红黑树`RBTree`来存储PCB，并提供了插入、删除和查询最小虚拟运行时间等操作。同时，由于多核心系统可能存在并发访问的问题，需要使用自旋锁`RawSpinlock`来保证线程安全性。

此外，该代码还包含了一些函数，如`__get_cfs_scheduler()`用于获取CFS调度器的引用，`sched_cfs_init()`初始化CFS调度器等功能。

总而言之，该代码实现了一个高效的CFS调度器，可以用于管理进程的调度。

这段代码实现了CFS调度器的主要逻辑。首先定义了一个`SchedulerCFS`结构体，其中包含了每个CPU核心对应的调度队列`cpu_queue`。在函数`new()`中，通过手动指定核心数目以及对于每个核心创建一个新的`CFSQueue`来初始化调度器。

在`update_cpu_exec_proc_jiffies()`函数中，通过引入调度周期和进程优先权计算出分配给进程的可执行时间，并进行更新操作。

在`timer_update_jiffies()`函数中，通过获取当前CPU核心的调度队列，并更新进程的可执行时间和虚拟运行时间等信息。

在`enqueue_reset_vruntime()`函数中，将进程加入到其对应的CPU核心的调度队列中，并且根据队列中最小虚拟运行时间来重设进程的虚拟运行时间。

总而言之，这段代码实现了一个完整的CFS调度器，可以用于管理多核心系统中的进程调度。

这段代码实现了`Scheduler` trait 中的两个方法：`sched()`和`enqueue()`。

在`sched()`函数中，首先重置当前进程的状态，并获取当前CPU核心的调度队列。然后从队列中出队一个优先级最高的进程，如果当前进程不是运行态或者虚拟运行时间大于等于下一个进程，则进行进程切换并返回该进程。否则，将当前进程重新加入到就绪队列，设置进程可执行时间并返回空值表示不需要进程切换。

在`enqueue()`方法中，将给定进程加入到其对应的CPU核心的调度队列中。

总而言之，这段代码实现了`Scheduler` trait 中定义的方法，可以让CFS调度器作为一种调度策略来管理操作系统中的进程。
