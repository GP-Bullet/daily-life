#### Rust风格代码

问题

- 各种全局变量。-> 大部分的全局变量都能变成结构体的成员变量。
- 对象、函数职责分配不清晰，出现各种“超出职责”的代码。并且出现很多的散装函数。-> 面向对象编程中，职责分配清晰是很关键的。
- 用RwLock或者SpinLock去保护一个usize之类的。-> 这种完全可以使用原子变量去做，而不需要用锁这种比较heavy的东西。
- 变量、结构体命名不规范。变量名字不能读懂是什么含义，以及各种无意义的“缩写”。->具体的话看dragonos文档里面的代码规范文档。
- 全局常量、变量没有放在文件顶部 -> 全局量往往是导致bug的东西，这样到处放置的话让其他人怎么能快速找到这些全局量？
- 注释和函数行为不一致->就是，更新函数功能的时候，一定要检查注释是否过时。。。
- 注释的格式不规范 -> 看代码规范文档
- 代码长的很C风格.这样的代码是很难维护的。也是新手最常见的。-> 牢记“函数指针=trait”、“union=枚举”、枚举的trait能够实现各种功能。 这几句话。因为一旦不遵守了这几句话，代码就很不符合rust的best practice，很难维护，也很难debug

补充一下这句话的解释：

\```代码长的很C风格.这样的代码是很难维护的。也是新手最常见的。-> 牢记“函数指针=trait”、“union=枚举”、枚举的trait能够实现各种功能。 这几句话。因为一旦不遵守了这几句话，代码就很不符合rust的best practice，很难维护，也很难debug```

- “函数指针=trait”指的是：c里面很多那种类似于xxx_ops的结构体，存满了函数指针的。这不就是trait吗（对应UML课程里面讲的接口）
- “union=枚举”指的是，好几个同学都尝试过使用union来存数据，觉得枚举类型存数据会占很多空间。union首先没有安全保证，并且还会导致很多地方语义难以判断。使用union会降低代码的可维护性。而rust的枚举其实就能解决很多的问题。



rust枚举类型存数据并不会占用很多空间，其底层会采用多种方法进行内存优化，包括将enum转化成union，所以需要有enum存数据的场景直接用enum就行了

还有就是代码耦合性问题，这个跟设计以及编码都很有关系。新手的常见问题就是代码职责不明确，耦合度很高，这样的代码看的真的很头大的

15:16

```
cr的时候咱看到的地方，也会指出来，帮助大家调整。自己编写的时候也要时刻想清楚这个职责分配、耦合度问题哦～
```

```
kthread的地方，很多裸指针，以及位运算没有封装。然后rust里面也不应该使用kzalloc这种不安全的方式申请内存，而是用rust自身的box啊或者arc这些来创建对象
```

15:53

```
然后rust里面写的kthread代码，看着就是C的原样翻译，这样是不ok的哈哈
```

```
内核线程的操作，可以封装成trait，或者是某个固定的结构体的。而不是裸指针搞了一个worker_private
```

15:56

```
主要是用好枚举和trait
```

然后进一步的话就是arc指针

然后错误处理应该是返回Result类型，而不是像C那样整错误码

因此kthread那块应该是要重写的，因为

- 没有做到很好的封装性
- 使用了很多裸指针
- 不符合rust的编程习惯，没有用好“枚举”+"trait“，而是直接将C代码原样翻译了过来

然后最后一点是，pr的时候，代码要 cd kernel && cargo fmt